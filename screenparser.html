<!DOCTYPE html>
<html>
  <head>
    <script src="https://docs.opencv.org/4.1.1/opencv.js" type="text/javascript"></script>
    <script src="https://unpkg.com/tesseract.js@2.1.5/dist/tesseract.min.js" type="text/javascript"></script>
    <script>
      const connect_file_img = (imageid, fileinputid) => {
        let imgElement = document.getElementById(imageid);
        let inputElement = document.getElementById(fileinputid);
        inputElement.addEventListener('change', (e) => {
          imgElement.src = URL.createObjectURL(e.target.files[0]);
        }, false);
      }

      const prepareItem = (domidIn, domidCanvasOut, itemSizePx) => {
        let src = cv.imread(domidIn);
        let step = new cv.Mat();
        let dst = new cv.Mat();
        cv.cvtColor(src, step, cv.COLOR_RGBA2GRAY, 0);
        let dsize = new cv.Size(itemSizePx, itemSizePx);
        // You can try more different parameters
        cv.resize(step, dst, dsize, 0, 0, cv.INTER_AREA);
        cv.imshow(domidCanvasOut, dst);
        src.delete(); dst.delete();
        console.info("item shrinked");
      }

      const imgmatch = (domidHaystack, domidNeedle, domidCanvasOut) => {
        let src = cv.imread(domidHaystack);
        let templ = cv.imread(domidNeedle);
        let dst = new cv.Mat();
        let mask = new cv.Mat();
        let foo = new cv.Mat();
        let buffer = cv.matchTemplate(src, templ, dst, cv.TM_CCOEFF_NORMED, mask);
        for (let i = 0; i <= 20; i++){
                  let result = cv.minMaxLoc(dst, mask);
                  let maxPoint = result.maxLoc;
                  console.log(255 - i * 20);
                  cv.floodFill(dst, foo, maxPoint, new cv.Scalar());
                  let color = new cv.Scalar(255 - i * 10, 0, 0, 255);
                  let point = new cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);
                  cv.rectangle(src, maxPoint, point, color, 1, cv.LINE_8, 0);
              }
        cv.imshow(domidCanvasOut, src);
        src.delete(); dst.delete(); mask.delete();
      }

      const drawRect = (domidCanvas, x0, y0, x1, y1) => {
        let src = cv.imread(domidCanvas);
        let color = new cv.Scalar(0, 255, 0, 255);
        let point = new cv.Point(x0, y0);
        let size = new cv.Point(x1, y1);
        cv.rectangle(src, point, size, color, 1, cv.LINE_8, 0);
        cv.imshow(domidCanvas, src);
      };

      // works: tesseract --oem 0 --psm 11 -l "eng" fhq-seaport-curve1.png cmd -c tessedit_write_images=T
      // returns: width an item icon should have in pixels
      const ocr = (domidCanvas) => {
        const worker = Tesseract.createWorker({
          logger: m => console.log(m)
        });

        return (async () => {
          await worker.load();
          await worker.loadLanguage('eng');
          await worker.initialize('eng');
          const params = {
            //'tessedit_ocr_engine_mode': 0,
            //'tessedit_pageseg_mode': 11,
            'tessedit_ocr_engine_mode': Tesseract.OEM.TESSERACT_ONLY,
            'tessedit_pageseg_mode': Tesseract.PSM.SPARSE_TEXT,
            //'tessedit_char_whitelist': 'Seaport',
            // 'tessjs_create_osd': '1'
            //'tessjs_create_tsv': '1'
          };
          await worker.setParameters(params);
          let imgElement = document.getElementById(domidCanvas);
          //let imgElement = document.getElementById('imageSrc');
          const result = await worker.recognize(imgElement);
          console.debug(result);
          console.debug(result.data.text);

          const seaportIdx = result.data.words.findIndex((word) => {
            return word.text == "Seaport";
          });
          const word = result.data.words[seaportIdx];
          const width = seaport2Icon(word.bbox.x1 - word.bbox.x0);

          const markWord = (word) => {
            console.log(word);
            console.log("icon width should be ", seaport2Icon(word.bbox.x1 - word.bbox.x0));
            drawRect(domidCanvas, word.bbox.x0, word.bbox.y0, word.bbox.x1, word.bbox.y1);
          }
          markWord(result.data.words[seaportIdx]);
          markWord(result.data.words[seaportIdx+1]);
          markWord(result.data.words[seaportIdx+2]);
          markWord(result.data.words[seaportIdx+3]);
          markWord(result.data.words[seaportIdx+4]);
          markWord(result.data.words[seaportIdx+5]);
          markWord(result.data.words[seaportIdx+6]);
          await worker.terminate();

          return width
        })();
      }

      // https://stackoverflow.com/questions/26941168/javascript-interpolate-an-array-of-numbers
      const interpolateArray = (data, fitCount) => {
        var linearInterpolate = function (before, after, atPoint) {
          return before + (after - before) * atPoint;
        };

        var newData = new Array();
        var springFactor = new Number((data.length - 1) / (fitCount - 1));
        newData[0] = data[0]; // for new allocation
        for ( var i = 1; i < fitCount - 1; i++) {
          var tmp = i * springFactor;
          var before = new Number(Math.floor(tmp)).toFixed();
          var after = new Number(Math.ceil(tmp)).toFixed();
          var atPoint = tmp - before;
          newData[i] = linearInterpolate(data[before], data[after], atPoint);
        }
        newData[fitCount - 1] = data[data.length - 1]; // for new allocation
        return newData;
      }

      const postprocessSeaport = (domidIn, domidCanvasOut) => {
        let src = cv.imread(domidIn);
        let step = new cv.Mat();
        let step2 = new cv.Mat();
        let dst = new cv.Mat();
        cv.cvtColor(src, step, cv.COLOR_RGBA2GRAY, 0);
        //let lut = [];
        //lut += interpolateArray([0, 0], 256/2);
        //lut += interpolateArray([0, 7*(256/8)], 7*(256/8));
        //lut += interpolateArray([7*(256/8), 255], 1*(256/8));
        //console.log(lut);
        //cv.LUT(src, lut, dst);
        cv.threshold(step, step2, 0.75*256, 255, cv.THRESH_BINARY);
        //cv.threshold(step, dst, 0.65*256, 0, cv.THRESH_TOZERO);
        cv.bitwise_not(step2, dst);
        cv.imshow(domidCanvasOut, dst);
        src.delete(); step.delete(); dst.delete();
      }

      // pixel on fhd
      const seaport2Icon = (width) => {
        // icon.width / seaport.width = x / width
        const f = 32.0 * width / 51.0;
        return Math.round(f);
      }

      const run = () => {
        console.log("run");
        postprocessSeaport('imageSrc', 'canvasOCR');
        drawRect('canvasOCR', 90, 90, 100, 100);
        const width = ocr('canvasOCR');
        prepareItem('imageTempl', 'canvasItem', width);
        imgmatch('imageSrc', 'canvasItem', 'canvasImgmatch');
      }
    </script>
    <style>
      #imageSrc, #imageTempl {
        # max-width: 300px;
      }
    </style>
  </head>
  <body>
    pe<b>n</b>is<br />
    <div>
      <div class="inputoutput">
        <img id="imageSrc" alt="No Image" />
        <div class="caption">imageSrc <input type="file" id="fileInputSrc" name="file" /></div>
      </div>
      <div class="inputoutput">
        <img id="imageTempl" alt="No Image" />
        <div class="caption">imageTempl <input type="file" id="fileInputTempl" name="file" /></div>
      </div>
      <button id="run" onclick="run();">Run it</button>
      <div class="inputoutput">
        <canvas id="canvasItem" ></canvas>
        <div class="caption">canvasItem</div>
      </div>
      <div class="inputoutput">
        <canvas id="canvasImgmatch" ></canvas>
        <div class="caption">canvasImgmatch</div>
      </div>
      <div class="inputoutput">
        <canvas id="canvasOCR" ></canvas>
        <div class="caption">canvasOCR</div>
      </div>
    </div>
    <script>
      connect_file_img('imageSrc', 'fileInputSrc');
      connect_file_img('imageTempl', 'fileInputTempl');
    </script>
  </body>
</html>
